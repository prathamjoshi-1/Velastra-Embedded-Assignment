# ğŸ“˜ Embedded Systems Assignment (C Language)

This repository contains an embedded systems assignment implemented in **C**, focusing on core firmware concepts such as **I2C sensor handling**, **fault detection and recovery**, and **data structure design**.

---

## ğŸ§© Problem 1: I2C Sensor Handling on Raspberry Pi (Mock Implementation)

### ğŸ”§ Design Decisions
- ğŸ§ª **Mock Sensor Model**  
  A software-based sensor (`MockSensor`) is used to simulate an actual I2C device, enabling validation of firmware logic without requiring physical hardware.

- ğŸ”„ **State Machine Architecture**  
  The system is designed using a simple state machine with two states:
  - `STATE_OPERATIONAL` â€“ Normal sensor polling
  - `STATE_RECOVERING` â€“ Activated when the sensor disconnects

- â±ï¸ **Fixed Polling Interval**  
  Sensor data is polled every **500 ms**, reflecting realistic embedded polling intervals.

- âš ï¸ **Fault Injection & Handling**  
  Randomized logic is used to simulate:
  - I2C bus timeouts
  - Invalid sensor data
  - Runtime sensor disconnection  
  All fault events are logged with timestamps.

- â™»ï¸ **Graceful Recovery Mechanism**  
  The system automatically attempts sensor reinitialization when a disconnection is detected, without terminating execution.

- ğŸ–¥ï¸ **Cross-Platform Compatibility**  
  Conditional compilation allows the code to run on both **Windows** and **Linux/Raspberry Pi** environments.

---

### â–¶ï¸ How to Build / Run the Code

#### Compile
```bash
gcc i2c_sensor_simulation.c -o sensor_app

Run

./sensor_app

Output

Timestamped sensor readings

Error logs for timeout, invalid data, and disconnection

Automatic recovery status messages


ğŸ“¸ Paste output screenshot here


---

ğŸ“ Assumptions

I2C sensor behavior is simulated using software

No direct access to /dev/i2c-* is required

Randomized failures reasonably represent real I2C fault scenarios

Second-level timestamp precision is sufficient for logging



---

ğŸ§© Problem 2: Stack Implementation in C (Linked List)

This module implements a stack data structure using a linked list to store sensor error codes generated by the system.
The implementation adheres to strict constraints commonly encountered in embedded firmware development.


---

ğŸ”§ Design Decisions

ğŸ§± Linked List Based Stack
A linked list is used instead of an array to demonstrate dynamic memory management and clear node-based logic.

ğŸ”¢ Fixed Maximum Size (32 Nodes)
The stack is limited to 32 entries, reflecting typical memory constraints in embedded systems.

ğŸ” Circular Overflow Behavior
When the stack reaches its maximum capacity, the oldest entry is removed before inserting a new one, ensuring the most recent error history is retained.

ğŸš« Non-Recursive Implementation
All stack operations are implemented iteratively, strictly following the â€œno recursionâ€ requirement.

ğŸ›¡ï¸ Robust Error Handling
The implementation safely handles:

Stack underflow conditions

Dynamic memory allocation failures


ğŸ§© Clear Separation of Logic
Stack initialization, push, pop, overflow handling, and display logic are modularized for readability and maintainability.



---

â–¶ï¸ How to Build / Run the Code

Compile

gcc stack_error_logger.c -o stack_app

Run

./stack_app

Output

Displays stack contents and current size

Demonstrates circular overwrite behavior

Shows the most recently popped error code


ğŸ“¸ Paste output screenshot here


---

ğŸ“ Assumptions

The stack stores only predefined sensor error codes

Stack size remains small, making traversal overhead acceptable

Memory cleanup is handled by the operating system on program termination



---

ğŸ‘¨â€ğŸ’» Author

Pratham Joshi
Electronics & Telecommunication Engineering
Embedded Systems | Firmware Development | C Programming

---

